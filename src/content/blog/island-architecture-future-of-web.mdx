---
title: "Island Architecture: The Pattern Shaping the Future of the Modern Web"
titleVi: "Island Architecture: Kiến trúc đang định hình tương lai của Web hiện đại"
description: "Island Architecture challenges the SPA-first mindset by hydrating only what needs to be interactive — delivering faster, leaner websites without sacrificing rich user experiences."
descriptionVi: "Island Architecture thách thức tư duy SPA bằng cách chỉ hydrate những gì thực sự cần tương tác — mang lại website nhanh hơn, nhẹ hơn mà không đánh đổi trải nghiệm người dùng."
pubDate: 2026-02-18
author: "Vinh Nguyen (Vincent)"
tags: ["Architecture", "Astro", "Performance", "Frontend"]
---

import Callout from '../../components/blog/Callout.astro';

{/* English Version */}
<div data-lang="en">

Over the past few years, the frontend world has seen an explosion of frameworks — React, Vue, Svelte, and more. But as websites grew heavier and more complex, a fundamental question surfaced: do we really need to ship an entire JavaScript bundle for the whole page just to power a handful of interactive components?

The answer is no — and that is exactly why Island Architecture was born.

## What Is Island Architecture?

Island Architecture is a UI rendering model where:

- The **majority of the page is rendered as static HTML** — no JavaScript required.
- Only **interactive components** (forms, carousels, search boxes, etc.) are "hydrated" with JavaScript.
- Each interactive component is treated as an **independent island** — it can use a different framework, runs in isolation, and only loads when needed.

In other words: instead of turning an entire page into a heavyweight SPA, you inject JavaScript only where it is truly necessary.

<Callout type="info" title="The Core Idea">
  Think of a standard webpage as an ocean of static content. Interactive widgets — a search bar, a shopping cart counter, a live ticker — are the **islands** rising from that ocean. Each island is self-contained and hydrated independently.
</Callout>

## Why Does This Architecture Matter?

### 1. Superior Performance

Most content is statically rendered → fast load times, strong SEO, low Time-to-Interactive.
JavaScript is only loaded for the components that actually need it → less pressure on the browser.

### 2. Better User Experience

Users see content immediately, without waiting for a massive JS bundle to download and execute. Interactive islands load progressively and do not block the rest of the page.

### 3. Easier to Maintain and Scale

Each island is an independent module:

- easy to debug
- easy to replace
- easy to upgrade

You can write one section in React and another in Svelte without either affecting the other.

### 4. A Natural Fit for Content-Heavy Sites

Blogs, landing pages, documentation sites, e-commerce product pages — none of these require a full-page SPA. Island Architecture keeps your page lightweight while still enabling interactivity wherever it is needed.

## A Simple Example

Imagine a blog page:

- Header, footer, and article body → static HTML
- Newsletter sign-up form → React island
- Search bar → Svelte island
- Image gallery slider → Vue island

Each interactive section is its own island — JavaScript is only loaded for the sections a user actually interacts with.

<Callout type="success" title="What This Means in Practice">
  A reader who never opens the search bar never downloads the Svelte code that powers it. The page stays fast for everyone, regardless of which features they use.
</Callout>

## Who Is Using Island Architecture?

Several modern frameworks have adopted or drawn inspiration from this model:

| Framework | Adoption Level |
| :--- | :--- |
| **Astro** | Built 100% around Island Architecture |
| **Qwik** | Extends the idea with "resumability" — no hydration at all |
| **Next.js / Nuxt** | Can approximate islands via React Server Components / partial hydration |
| **Marko** | Has supported islands natively since early on |

Among these, **Astro** is the standout — it was designed around this architecture from day one, which is why it has become the go-to choice for content-focused sites.

## How Do Islands Communicate With Each Other?

Here is the tricky part: if each island is isolated, how does clicking "Add to Cart" on a Product island (React) update the item count on the Cart island (Svelte) in the header?

Without a shared component tree like a SPA, there are three common solutions:

### 1. Custom Events (Native Browser API)

The most primitive approach. One island dispatches a browser event; another island listens for it via the `window` object.

```javascript
// Product island (React) — dispatches the event
window.dispatchEvent(new CustomEvent('cart:updated', { detail: { count: 3 } }));

// Cart island (Svelte) — listens for the event
window.addEventListener('cart:updated', (e) => {
  cartCount = e.detail.count;
});
```

**Pros:** No external dependencies, extremely lightweight.
**Best for:** Simple, infrequent cross-island interactions.

### 2. Nano Stores

This is the recommended solution when working with Astro. [Nano Stores](https://github.com/nanostores/nanostores) is a tiny (under 1 kB), framework-agnostic state management library.

```javascript
// store.js — shared store
import { atom } from 'nanostores';
export const cartCount = atom(0);

// Product island (React)
import { useStore } from '@nanostores/react';
import { cartCount } from './store';
const count = useStore(cartCount);
cartCount.set(count + 1);

// Cart island (Svelte)
import { useStore } from '@nanostores/svelte';
import { cartCount } from './store';
$: count = $cartCount;
```

**Pros:** Works seamlessly across different frameworks; reactive by default.
**Best for:** Shared state that multiple islands need to read and write.

### 3. URL Query Parameters

Use the URL itself as the source of truth for state (filters, pagination, tab selections).

```javascript
// Any island can update the URL
const url = new URL(window.location);
url.searchParams.set('page', '2');
window.history.pushState({}, '', url);

// Any island can read from the URL
const page = new URLSearchParams(window.location.search).get('page');
```

**Pros:** State survives page refreshes; users can share exact page states via URL.
**Best for:** Filterable lists, search results, paginated content.

<Callout type="warning" title="The Golden Rule">
  Keep inter-island communication minimal. If two components need to share a large amount of complex state, they probably belong in the same island. Reach for Nano Stores when the communication genuinely needs to cross island boundaries.
</Callout>

## Island Architecture vs. Traditional SPA

| | Traditional SPA | Island Architecture |
| :--- | :--- | :--- |
| **JavaScript loading** | Full bundle for the entire page | Per-component, on demand |
| **Rendering** | Mostly client-side | Mostly server/static, hydrate only what's needed |
| **Bundle bloat risk** | High | Naturally minimized |
| **Best suited for** | Complex, highly interactive apps | Content-heavy websites |
| **SEO out of the box** | Requires extra configuration | Excellent — static HTML first |
| **Framework flexibility** | One framework per app | Different frameworks per island |

SPAs are not inherently bad — but they are not the optimal choice for every type of website. A blog does not need the same architecture as a real-time trading dashboard.

## The Future of the Web

Island Architecture is not a passing trend. It reflects a deeper shift in how the industry thinks about building for the web:

> **The web does not need as much JavaScript as we once assumed.**

As users demand faster experiences and browsers impose stricter performance budgets, frameworks will continue optimizing toward "less JavaScript, smarter JavaScript." Island Architecture is one of the most important steps in that journey. Concepts like Qwik's resumability and React Server Components are direct extensions of this same philosophy.

## Conclusion

Island Architecture offers a fresh, efficient approach to building websites:

- **faster** — static HTML reaches the user immediately
- **lighter** — JavaScript is only loaded where it is actually used
- **more scalable** — each island is an independent, replaceable module
- **more flexible** — mix frameworks without coupling them together

If you are building a blog, a landing page, documentation, or any content-driven website, now is a great time to explore this architecture — especially with a framework like **Astro**, which makes Island Architecture the default rather than an afterthought.

<Callout type="info" title="Where to Start">
  If you are new to Island Architecture, the best entry point is the [Astro documentation](https://docs.astro.build/en/concepts/islands/). It explains the concepts clearly and provides hands-on examples for adding interactive islands to an otherwise static page.
</Callout>

</div>

{/* Vietnamese Version */}
<div data-lang="vi">

Trong vài năm trở lại đây, thế giới front-end chứng kiến sự bùng nổ của các framework như React, Vue, Svelte… Tuy nhiên, khi các trang web ngày càng nặng nề và phức tạp, một câu hỏi lớn xuất hiện: Có thật sự cần tải toàn bộ JavaScript cho cả trang chỉ để chạy vài thành phần tương tác nhỏ?

Câu trả lời là không — và đó chính là lý do Island Architecture ra đời.

## Island Architecture là gì?

Island Architecture (kiến trúc "đảo") là một mô hình xây dựng giao diện web trong đó:

- **Phần lớn trang được render dưới dạng HTML tĩnh**, không cần JavaScript.
- Chỉ những **thành phần tương tác** (như form, carousel, search box…) mới được "hydrate" bằng JavaScript.
- Mỗi thành phần tương tác được xem như một **đảo độc lập** — có thể dùng framework khác nhau, chạy tách biệt và chỉ tải khi cần.

Nói cách khác: thay vì biến cả trang thành một SPA nặng nề, ta chỉ "bơm" JavaScript vào những nơi thật sự cần thiết.

<Callout type="info" title="Ý tưởng cốt lõi">
  Hãy hình dung một trang web như một đại dương nội dung tĩnh. Các widget tương tác — thanh tìm kiếm, giỏ hàng, bảng tin trực tiếp — là những **hòn đảo** nổi lên từ đại dương đó. Mỗi đảo tự chứa đựng và được hydrate độc lập.
</Callout>

## Vì sao kiến trúc này quan trọng?

### 1. Hiệu năng vượt trội

Hầu hết nội dung được render tĩnh → tải nhanh, SEO tốt, Time-to-Interactive thấp.
JavaScript chỉ được tải cho những phần cần thiết → giảm tải cho trình duyệt.

### 2. Tối ưu trải nghiệm người dùng

Người dùng thấy nội dung ngay lập tức, không phải chờ bundle JS khổng lồ tải và chạy. Các "đảo" tương tác được tải dần, không làm nghẽn toàn bộ trang.

### 3. Dễ bảo trì và mở rộng

Mỗi đảo là một module độc lập:

- dễ debug
- dễ thay thế
- dễ nâng cấp

Bạn có thể viết một phần bằng React, phần khác bằng Svelte mà không ảnh hưởng nhau.

### 4. Phù hợp với các trang content-heavy

Blog, landing page, docs, e-commerce… đều không cần SPA toàn trang. Island Architecture giúp bạn giữ trang nhẹ nhưng vẫn có tương tác khi cần.

## Ví dụ đơn giản

Hãy tưởng tượng một trang blog:

- Header, footer, nội dung bài viết → HTML tĩnh
- Form đăng ký newsletter → đảo React
- Thanh tìm kiếm → đảo Svelte
- Slider hình ảnh → đảo Vue

Mỗi phần tương tác là một "đảo" riêng, chỉ tải JS khi người dùng cần.

<Callout type="success" title="Điều này có nghĩa gì trong thực tế">
  Một người đọc không bao giờ mở thanh tìm kiếm sẽ không bao giờ tải code Svelte vận hành nó. Trang vẫn nhanh với mọi người, bất kể họ dùng tính năng nào.
</Callout>

## Ai đang sử dụng Island Architecture?

Nhiều framework hiện đại đã áp dụng hoặc lấy cảm hứng từ mô hình này:

| Framework | Mức độ áp dụng |
| :--- | :--- |
| **Astro** | 100% dựa trên Island Architecture |
| **Qwik** | Mở rộng ý tưởng với "resumability" — không cần hydration |
| **Next.js / Nuxt** | Có thể mô phỏng islands qua React Server Components / partial hydration |
| **Marko** | Tích hợp islands natively từ sớm |

Trong đó, **Astro** là framework nổi bật nhất vì được thiết kế xoay quanh kiến trúc này ngay từ đầu, trở thành lựa chọn hàng đầu cho các site tập trung vào nội dung.

## Làm sao để các "hòn đảo" giao tiếp với nhau?

Đây là phần phức tạp: nếu các hòn đảo nằm tách biệt, làm sao để khi ta nhấn "Thêm vào giỏ hàng" ở đảo Sản phẩm (React), thì số lượng trên đảo Giỏ hàng (Svelte) ở Header được cập nhật?

Vì không có một "cây Component" chung duy nhất như SPA, có 3 cách phổ biến để giải quyết:

### 1. Custom Events (Native Browser API)

Cách "thuần" nhất. Một hòn đảo phát ra sự kiện (dispatch event); hòn đảo kia lắng nghe qua đối tượng `window`.

```javascript
// Đảo Sản phẩm (React) — phát sự kiện
window.dispatchEvent(new CustomEvent('cart:updated', { detail: { count: 3 } }));

// Đảo Giỏ hàng (Svelte) — lắng nghe sự kiện
window.addEventListener('cart:updated', (e) => {
  cartCount = e.detail.count;
});
```

**Ưu điểm:** Không cần thư viện ngoài, cực nhẹ.
**Phù hợp:** Các tương tác đơn giản, không thường xuyên giữa các đảo.

### 2. Nano Stores

Đây là giải pháp khuyến nghị khi làm việc với Astro. [Nano Stores](https://github.com/nanostores/nanostores) là thư viện quản lý state cực nhỏ (dưới 1 kB) và không phụ thuộc framework.

```javascript
// store.js — store dùng chung
import { atom } from 'nanostores';
export const cartCount = atom(0);

// Đảo Sản phẩm (React)
import { useStore } from '@nanostores/react';
import { cartCount } from './store';
const count = useStore(cartCount);
cartCount.set(count + 1);

// Đảo Giỏ hàng (Svelte)
import { useStore } from '@nanostores/svelte';
import { cartCount } from './store';
$: count = $cartCount;
```

**Ưu điểm:** Hoạt động liền mạch trên nhiều framework khác nhau; reactive theo mặc định.
**Phù hợp:** State dùng chung mà nhiều đảo cần đọc và ghi.

### 3. URL Query Parameters

Dùng chính URL để lưu trạng thái (bộ lọc tìm kiếm, số trang, tab đang chọn...).

```javascript
// Bất kỳ đảo nào cũng có thể cập nhật URL
const url = new URL(window.location);
url.searchParams.set('page', '2');
window.history.pushState({}, '', url);

// Bất kỳ đảo nào cũng có thể đọc từ URL
const page = new URLSearchParams(window.location.search).get('page');
```

**Ưu điểm:** Trạng thái tồn tại qua reload trang; người dùng có thể chia sẻ URL với trạng thái chính xác.
**Phù hợp:** Danh sách có bộ lọc, kết quả tìm kiếm, nội dung phân trang.

<Callout type="warning" title="Quy tắc vàng">
  Hãy giữ cho việc giao tiếp giữa các đảo ở mức tối thiểu. Nếu hai thành phần cần chia sẻ quá nhiều dữ liệu phức tạp, có lẽ chúng nên thuộc về cùng một hòn đảo. Dùng Nano Stores khi việc giao tiếp thực sự cần vượt qua ranh giới giữa các đảo.
</Callout>

## Island Architecture khác gì SPA truyền thống?

| | SPA truyền thống | Island Architecture |
| :--- | :--- | :--- |
| **Tải JavaScript** | Bundle đầy đủ cho toàn trang | Theo từng component, theo nhu cầu |
| **Render** | Chủ yếu client-side | Chủ yếu server/tĩnh, chỉ hydrate phần cần |
| **Nguy cơ JS bloat** | Cao | Được giảm thiểu tự nhiên |
| **Phù hợp nhất** | App phức tạp, tương tác cao | Website nặng về nội dung |
| **SEO sẵn có** | Cần cấu hình thêm | Xuất sắc — HTML tĩnh là ưu tiên |
| **Linh hoạt framework** | Một framework cho toàn app | Framework khác nhau cho từng đảo |

SPA không phải là xấu — nhưng nó không phải lựa chọn tối ưu cho mọi loại website. Một blog không cần cùng kiến trúc với một bảng điều khiển giao dịch thời gian thực.

## Tương lai của Web?

Island Architecture không phải xu hướng nhất thời. Nó phản ánh một sự thay đổi lớn hơn trong cách ngành này nghĩ về việc xây dựng cho web:

> **Web không cần nhiều JavaScript như chúng ta từng nghĩ.**

Khi người dùng đòi hỏi tốc độ và trải nghiệm mượt mà hơn, các framework sẽ tiếp tục tối ưu theo hướng "ít JavaScript hơn, thông minh hơn". Island Architecture chính là bước tiến quan trọng trong hành trình đó. Các khái niệm như resumability của Qwik hay React Server Components đều là sự mở rộng trực tiếp của triết lý này.

## Kết luận

Island Architecture mang đến một cách tiếp cận mới mẻ và hiệu quả cho việc xây dựng website:

- **nhanh hơn** — HTML tĩnh đến tay người dùng ngay lập tức
- **nhẹ hơn** — JavaScript chỉ được tải ở nơi thực sự dùng đến
- **dễ mở rộng hơn** — mỗi đảo là một module độc lập, có thể thay thế
- **linh hoạt hơn** — kết hợp nhiều framework mà không ràng buộc lẫn nhau

Nếu bạn đang xây dựng blog, landing page, trang tài liệu hoặc bất kỳ website nội dung lớn nào, đây là thời điểm tuyệt vời để thử nghiệm kiến trúc này — đặc biệt với **Astro**, framework biến Island Architecture thành mặc định thay vì một suy nghĩ thêm.

<Callout type="info" title="Bắt đầu từ đâu">
  Nếu bạn mới làm quen với Island Architecture, điểm khởi đầu tốt nhất là [tài liệu của Astro](https://docs.astro.build/en/concepts/islands/). Nó giải thích các khái niệm rõ ràng và cung cấp ví dụ thực hành về việc thêm các đảo tương tác vào trang tĩnh.
</Callout>

</div>
