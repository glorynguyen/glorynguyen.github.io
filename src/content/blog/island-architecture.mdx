---
title: "Island Architecture: The Pattern Shaping the Future of the Modern Web"
titleVi: "Island Architecture: Kiến trúc đang định hình tương lai của Web hiện đại"
description: "Discover Island Architecture — the web design pattern that delivers blazing-fast performance by only hydrating interactive components, leaving the rest as static HTML."
descriptionVi: "Khám phá Island Architecture — mô hình thiết kế web mang lại hiệu năng vượt trội bằng cách chỉ hydrate các thành phần tương tác, giữ phần còn lại là HTML tĩnh."
pubDate: 2026-02-18
tags: ["Architecture", "Performance", "Astro", "Web Development"]
---

import Callout from '../../components/blog/Callout.astro';

{/* English Version */}
<div data-lang="en">

In recent years, the front-end world has witnessed an explosion of frameworks — React, Vue, Svelte, and more. Yet as websites grow heavier and more complex, a critical question emerges: **Do we really need to ship all that JavaScript just to power a handful of small interactive components?**

The answer is no — and that is precisely why Island Architecture was born.

## What Is Island Architecture?

Island Architecture is a UI building model in which:

- The **majority of the page is rendered as static HTML**, requiring no JavaScript.
- Only **interactive components** — such as forms, carousels, or search boxes — are **hydrated** with JavaScript.
- Each interactive component is treated as an **independent island** — it can use a different framework, runs in isolation, and only loads when needed.

In other words, instead of turning the entire page into a heavy SPA, you **inject JavaScript only where it is truly necessary**.

<Callout type="info" title="The Core Idea">
  Think of your webpage as an ocean of static HTML. Interactive widgets are small islands within that ocean — each self-contained, each only activating when a user actually needs them.
</Callout>

## Why Does This Architecture Matter?

### 1. Superior Performance

Most content is rendered statically → fast load times, great SEO, and a low Time-to-Interactive. JavaScript is only downloaded for the parts that need it, reducing the burden on the browser.

### 2. Optimised User Experience

Users see content immediately — no waiting for a massive JS bundle to download and parse. Interactive islands load progressively, without blocking the rest of the page.

### 3. Easy to Maintain and Scale

Each island is an independent module:

- easy to debug
- easy to replace
- easy to upgrade

You can write one part in React and another in Svelte without them affecting each other.

### 4. Perfect for Content-Heavy Sites

Blogs, landing pages, docs, e-commerce sites — none of them need a full-page SPA. Island Architecture lets you keep the page lightweight while still supporting interactivity wherever it is needed.

## A Simple Example

Imagine a blog page:

| Part | Technology |
|------|------------|
| Header, footer, article body | Static HTML |
| Newsletter sign-up form | React island |
| Search bar | Svelte island |
| Image slider | Vue island |

Each interactive piece is its own island — JS only loads when the user actually needs it.

## Who Is Using Island Architecture?

Many modern frameworks have adopted or drawn inspiration from this model:

| Framework | Level of Adoption |
|-----------|-------------------|
| **Astro** | 100% built on Island Architecture |
| **Qwik** | Optimises hydration via "resumability" |
| **Next.js / Nuxt** | Can simulate islands through partial hydration |
| **Marko** | Early adopter of the islands model |

Among these, **Astro** stands out the most — it was designed around this architecture from day one.

## How Do Islands Communicate With Each Other?

This is the tricky part: if islands are isolated, how does clicking "Add to Cart" on a Product island (React) update the cart count on a Cart Header island (Svelte)?

Because there is no single shared component tree as in an SPA, there are **three common approaches**:

### 1. Custom Events (Native Browser API)

The most framework-free approach. One island dispatches a custom event; another listens for it via the `window` object.

- **Pros:** No external libraries, extremely lightweight.
- **Best for:** Simple, one-off interactions.

### 2. Nano Stores

This is the **go-to solution** that pairs beautifully with Astro. Nano Stores is a tiny (under 1 kb), framework-agnostic state management library.

- **How it works:** You define a shared store. Both your React island and your Vue island can subscribe to it. When the value changes, all subscribing islands update automatically.
- **Pros:** Perfect multi-framework support.

### 3. URL Query Parameters

Use the URL itself to hold state (filters, page numbers, etc.).

- **How it works:** When a user selects a filter, the URL updates. Other islands read from the URL and render accordingly.
- **Pros:** Users can copy and share the link, preserving the exact page state.

<Callout type="success" title="The Golden Rule">
  Keep inter-island communication to a minimum. If two components need to share a large amount of complex data, they probably belong in the same island.
</Callout>

## Island Architecture vs. Traditional SPA

| Traditional SPA | Island Architecture |
|-----------------|---------------------|
| Loads all JS upfront for the entire page | Loads JS per component, on demand |
| All logic runs client-side | Mostly server-side; only hydrates what is needed |
| Prone to "JS bloat" | Naturally performance-optimised |
| Ideal for complex applications | Ideal for content-heavy websites |

SPAs are not bad — but they are not the optimal choice for every type of website.

## The Future of the Web?

Island Architecture is not a passing trend. It reflects a profound shift in thinking:

> **The web does not need as much JavaScript as we once believed.**

As users demand faster load times and smoother experiences, frameworks will continue to optimise toward "less JS, smarter JS." Island Architecture is a major step forward on that journey.

## Conclusion

Island Architecture offers a fresh and effective approach to building websites:

- **Faster** — static HTML loads instantly
- **Lighter** — only the JavaScript you actually need
- **More scalable** — independent modules are easy to manage
- **More flexible** — mix and match frameworks per island

If you are building a blog, a landing page, a documentation site, or any content-heavy website, now is a great time to explore this architecture — especially with frameworks like **Astro**.

</div>

{/* Vietnamese Version */}
<div data-lang="vi">

Trong vài năm trở lại đây, thế giới front‑end chứng kiến sự bùng nổ của các framework như React, Vue, Svelte… Tuy nhiên, khi các trang web ngày càng nặng nề và phức tạp, một câu hỏi lớn xuất hiện: **Có thật sự cần tải toàn bộ JavaScript cho cả trang chỉ để chạy vài thành phần tương tác nhỏ?**

Câu trả lời là không — và đó chính là lý do Island Architecture ra đời.

## Island Architecture là gì?

Island Architecture (kiến trúc "đảo") là một mô hình xây dựng giao diện web trong đó:

- **Phần lớn trang được render dưới dạng HTML tĩnh**, không cần JavaScript.
- Chỉ những **thành phần tương tác** (như form, carousel, search box…) mới được **hydrate** bằng JavaScript.
- Mỗi thành phần tương tác được xem như một **đảo độc lập** — có thể dùng framework khác nhau, chạy tách biệt và chỉ tải khi cần.

Nói cách khác: thay vì biến cả trang thành một SPA nặng nề, ta chỉ **"bơm" JavaScript vào những nơi thật sự cần thiết**.

<Callout type="info" title="Ý tưởng cốt lõi">
  Hãy hình dung trang web của bạn là một đại dương HTML tĩnh. Các widget tương tác là những hòn đảo nhỏ trong đại dương đó — mỗi đảo tự quản lý, chỉ kích hoạt khi người dùng thật sự cần.
</Callout>

## Vì sao kiến trúc này quan trọng?

### 1. Hiệu năng vượt trội

Hầu hết nội dung được render tĩnh → tải nhanh, SEO tốt, Time-to-Interactive thấp. JavaScript chỉ được tải cho những phần cần thiết → giảm tải cho trình duyệt.

### 2. Tối ưu trải nghiệm người dùng

Người dùng thấy nội dung ngay lập tức, không phải chờ bundle JS khổng lồ tải xong. Các "đảo" tương tác được tải dần, không làm nghẽn toàn bộ trang.

### 3. Dễ bảo trì và mở rộng

Mỗi đảo là một module độc lập:

- dễ debug
- dễ thay thế
- dễ nâng cấp

Bạn có thể viết một phần bằng React, phần khác bằng Svelte mà không ảnh hưởng nhau.

### 4. Phù hợp với các trang content-heavy

Blog, landing page, docs, e‑commerce… đều không cần SPA toàn trang. Island Architecture giúp bạn giữ trang nhẹ nhưng vẫn có tương tác khi cần.

## Ví dụ đơn giản

Hãy tưởng tượng một trang blog:

| Phần | Công nghệ |
|------|-----------|
| Header, footer, nội dung bài viết | HTML tĩnh |
| Form đăng ký newsletter | React island |
| Thanh tìm kiếm | Svelte island |
| Slider hình ảnh | Vue island |

Mỗi phần tương tác là một "đảo" riêng, chỉ tải JS khi người dùng cần.

## Ai đang sử dụng Island Architecture?

Nhiều framework hiện đại đã áp dụng hoặc lấy cảm hứng từ mô hình này:

| Framework | Mức độ áp dụng |
|-----------|----------------|
| **Astro** | 100% dựa trên Island Architecture |
| **Qwik** | Tối ưu hóa hydration theo hướng "resumability" |
| **Next.js / Nuxt** | Có thể mô phỏng islands qua partial hydration |
| **Marko** | Tích hợp islands từ sớm |

Trong đó, **Astro** là framework nổi bật nhất vì được thiết kế xoay quanh kiến trúc này ngay từ đầu.

## Làm sao để các "hòn đảo" giao tiếp với nhau?

Đây là câu hỏi hóc búa: Nếu các hòn đảo nằm tách biệt, làm sao để khi ta nhấn "Thêm vào giỏ hàng" ở đảo Sản phẩm (React), thì số lượng trên đảo Giỏ hàng (Svelte) ở Header được cập nhật?

Vì không có một "cây Component" chung duy nhất như SPA, chúng ta có **3 cách phổ biến** để giải quyết:

### 1. Sử dụng Custom Events (Native Browser API)

Đây là cách "thuần" nhất. Hòn đảo này phát ra một sự kiện (dispatch event) và hòn đảo kia lắng nghe sự kiện đó thông qua đối tượng `window`.

- **Ưu điểm:** Không cần thư viện ngoài, cực nhẹ.
- **Phù hợp:** Các tương tác đơn giản.

### 2. Sử dụng Nano Stores

Đây là giải pháp "vàng" thường đi kèm với Astro. Nano Stores là một thư viện quản lý state cực nhỏ (dưới 1kb) và framework-agnostic (không phụ thuộc framework).

- **Cách hoạt động:** Bạn tạo một store chung. Cả đảo React và đảo Vue đều có thể "subscribe" vào store này. Khi giá trị thay đổi, cả hai đảo đều tự động cập nhật.
- **Ưu điểm:** Hỗ trợ đa framework hoàn hảo.

### 3. URL Query Parameters

Dùng chính URL để lưu trạng thái (như bộ lọc tìm kiếm, số trang…).

- **Cách hoạt động:** Khi người dùng chọn bộ lọc, URL thay đổi. Các hòn đảo khác sẽ đọc thông tin từ URL để hiển thị dữ liệu tương ứng.
- **Ưu điểm:** Người dùng có thể copy link và chia sẻ chính xác trạng thái của trang.

<Callout type="success" title="Quy tắc vàng">
  Hãy giữ cho việc giao tiếp giữa các đảo ở mức tối thiểu. Nếu hai thành phần cần chia sẻ quá nhiều dữ liệu phức tạp với nhau, có lẽ chúng nên thuộc về cùng một hòn đảo.
</Callout>

## Island Architecture khác gì SPA truyền thống?

| SPA truyền thống | Island Architecture |
|------------------|---------------------|
| Tải toàn bộ JS cho cả trang | Tải JS theo từng thành phần |
| Tất cả logic chạy client-side | Chủ yếu server-side, chỉ hydrate phần cần |
| Dễ bị "JS bloat" | Tối ưu hiệu năng tự nhiên |
| Phù hợp app phức tạp | Phù hợp website nội dung lớn |

Không phải SPA không tốt — nhưng nó không phải lựa chọn tối ưu cho mọi loại website.

## Tương lai của web?

Island Architecture không phải xu hướng nhất thời. Nó phản ánh một sự thay đổi lớn:

> **Web không cần nhiều JavaScript như chúng ta từng nghĩ.**

Khi người dùng đòi hỏi tốc độ và trải nghiệm mượt mà hơn, các framework sẽ tiếp tục tối ưu theo hướng "ít JS hơn, thông minh hơn". Island Architecture chính là bước tiến quan trọng trong hành trình đó.

## Kết luận

Island Architecture mang đến một cách tiếp cận mới mẻ và hiệu quả cho việc xây dựng website:

- **Nhanh hơn** — HTML tĩnh tải ngay lập tức
- **Nhẹ hơn** — chỉ JavaScript thật sự cần thiết
- **Dễ mở rộng hơn** — các module độc lập dễ quản lý
- **Linh hoạt hơn** — kết hợp nhiều framework theo từng đảo

Nếu bạn đang xây dựng blog, landing page, trang tài liệu hoặc bất kỳ website nội dung lớn nào, đây là thời điểm tuyệt vời để thử nghiệm kiến trúc này — đặc biệt với những framework như **Astro**.

</div>
